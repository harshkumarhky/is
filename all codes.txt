1.Implement Caesar Cipher algorithm. (Encryption and decryption).........

def caesar_encrypt(text, shift):
    encrypted_text = ""
    for char in text:
        if char.isalpha():
            shifted = ord(char) + shift
            if char.islower():
                if shifted > ord('z'):
                    shifted -= 26
                elif shifted < ord('a'):
                    shifted += 26
            elif char.isupper():
                if shifted > ord('Z'):
                    shifted -= 26
                elif shifted < ord('A'):
                    shifted += 26
            encrypted_text += chr(shifted)
        else:
            encrypted_text += char
    return encrypted_text

def caesar_decrypt(text, shift):
    return caesar_encrypt(text, -shift)

# Example usage:
plaintext = "Hello, World!"
shift = 3
encrypted_text = caesar_encrypt(plaintext, shift)
print("Encrypted:", encrypted_text)
decrypted_text = caesar_decrypt(encrypted_text, shift)
print("Decrypted:", decrypted_text)


2.Implement Rail Fence algorithm. (Encryption and decryption)......


def rail_fence_encrypt(text, rails):
    fence = [[] for _ in range(rails)]
    rail = 0
    direction = 1

    for char in text:
        fence[rail].append(char)
        rail += direction
        if rail == rails - 1 or rail == 0:
            direction *= -1

    encrypted_text = ''.join([''.join(row) for row in fence])
    return encrypted_text

def rail_fence_decrypt(text, rails):
    fence = [['' for _ in text] for _ in range(rails)]
    rail = 0
    direction = 1

    for i in range(len(text)):
        fence[rail][i] = '*'
        rail += direction
        if rail == rails - 1 or rail == 0:
            direction *= -1

    index = 0
    for i in range(rails):
        for j in range(len(text)):
            if fence[i][j] == '*' and index < len(text):
                fence[i][j] = text[index]
                index += 1

    rail = 0
    direction = 1
    decrypted_text = ''
    for _ in text:
        decrypted_text += fence[rail][0]
        del fence[rail][0]
        rail += direction
        if rail == rails - 1 or rail == 0:
            direction *= -1

    return decrypted_text

# Example usage:
plaintext = "Hello, World!"
rails = 3
encrypted_text = rail_fence_encrypt(plaintext, rails)
print("Encrypted:", encrypted_text)
decrypted_text = rail_fence_decrypt(encrypted_text, rails)
print("Decrypted:", decrypted_text)

3.Implement Play fair algorithm. (Encryption and decryption)..........


def prepare_text(text):
    # Convert text to uppercase and remove spaces
    text = text.upper().replace(" ", "")
    # Replace 'J' with 'I'
    text = text.replace("J", "I")
    # Split text into digraphs
    digraphs = []
    i = 0
    while i < len(text):
        if i + 1 < len(text) and text[i] == text[i + 1]:
            digraphs.append(text[i] + "X")
            i += 1
        else:
            digraphs.append(text[i:i + 2])
            i += 2
    return digraphs

def build_playfair_matrix(key):
    # Initialize Playfair matrix with the key
    matrix = []
    for char in key.upper():
        if char not in matrix and char != "J":
            matrix.append(char)
    # Fill in the rest of the matrix with remaining letters
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in matrix:
            matrix.append(char)
    # Reshape matrix into a 5x5 grid
    matrix = [matrix[i:i + 5] for i in range(0, 25, 5)]
    return matrix

def find_letter_positions(matrix, letter):
    for i in range(5):
        for j in range(5):
            if matrix[i][j] == letter:
                return i, j

def playfair_encrypt(plaintext, key):
    plaintext = prepare_text(plaintext)
    matrix = build_playfair_matrix(key)
    ciphertext = ""
    for digraph in plaintext:
        row1, col1 = find_letter_positions(matrix, digraph[0])
        row2, col2 = find_letter_positions(matrix, digraph[1])
        if row1 == row2:
            ciphertext += matrix[row1][(col1 + 1) % 5] + matrix[row2][(col2 + 1) % 5]
        elif col1 == col2:
            ciphertext += matrix[(row1 + 1) % 5][col1] + matrix[(row2 + 1) % 5][col2]
        else:
            ciphertext += matrix[row1][col2] + matrix[row2][col1]
    return ciphertext

def playfair_decrypt(ciphertext, key):
    ciphertext = prepare_text(ciphertext)
    matrix = build_playfair_matrix(key)
    plaintext = ""
    for digraph in ciphertext:
        row1, col1 = find_letter_positions(matrix, digraph[0])
        row2, col2 = find_letter_positions(matrix, digraph[1])
        if row1 == row2:
            plaintext += matrix[row1][(col1 - 1) % 5] + matrix[row2][(col2 - 1) % 5]
        elif col1 == col2:
            plaintext += matrix[(row1 - 1) % 5][col1] + matrix[(row2 - 1) % 5][col2]
        else:
            plaintext += matrix[row1][col2] + matrix[row2][col1]
    return plaintext

# Example usage:
plaintext = "HELLO"
key = "PLAYFAIR EXAMPLE"
encrypted_text = playfair_encrypt(plaintext, key)
print("Encrypted:", encrypted_text)
decrypted_text = playfair_decrypt(encrypted_text, key)
print("Decrypted:", decrypted_text)



4.Implement Vigenere Cipher algorithm. (Encryption and decryption).........

def extend_keyword(keyword, length):
    extended_keyword = keyword
    while len(extended_keyword) < length:
        extended_keyword += keyword
    return extended_keyword[:length]

def vigenere_encrypt(plaintext, keyword):
    keyword = extend_keyword(keyword, len(plaintext))
    encrypted_text = ""
    for i in range(len(plaintext)):
        if plaintext[i].isalpha():
            shift = ord(keyword[i].upper()) - ord('A')
            if plaintext[i].islower():
                encrypted_text += chr((ord(plaintext[i]) - ord('a') + shift) % 26 + ord('a'))
            else:
                encrypted_text += chr((ord(plaintext[i]) - ord('A') + shift) % 26 + ord('A'))
        else:
            encrypted_text += plaintext[i]
    return encrypted_text

def vigenere_decrypt(ciphertext, keyword):
    keyword = extend_keyword(keyword, len(ciphertext))
    decrypted_text = ""
    for i in range(len(ciphertext)):
        if ciphertext[i].isalpha():
            shift = ord(keyword[i].upper()) - ord('A')
            if ciphertext[i].islower():
                decrypted_text += chr((ord(ciphertext[i]) - ord('a') - shift) % 26 + ord('a'))
            else:
                decrypted_text += chr((ord(ciphertext[i]) - ord('A') - shift) % 26 + ord('A'))
        else:
            decrypted_text += ciphertext[i]
    return decrypted_text

# Example usage:
plaintext = "HELLO"
keyword = "KEY"
encrypted_text = vigenere_encrypt(plaintext, keyword)
print("Encrypted:", encrypted_text)
decrypted_text = vigenere_decrypt(encrypted_text, keyword)
print("Decrypted:", decrypted_text)


5.Implement Hill Cipher algorithm. (Encryption and decryption) (Omitted from practical exam.).......

import numpy as np

def matrix_mod_inv(matrix, modulus):
    det = int(np.round(np.linalg.det(matrix)))
    det_inv = pow(det, -1, modulus)  # Calculate modular inverse of determinant

    # Calculate adjugate matrix
    adjugate = np.round(det * np.linalg.inv(matrix)).astype(int) % modulus

    # Calculate inverse matrix
    inverse = (det_inv * adjugate) % modulus

    return inverse

def matrix_to_numbers(matrix):
    return [ord(char) - ord('A') for char in ''.join(matrix)]

def numbers_to_matrix(numbers):
    return ''.join([chr(num % 26 + ord('A')) for num in numbers])

def hill_encrypt(plaintext, key):
    key_matrix = np.array(key)
    plaintext = plaintext.upper().replace(" ", "")
    n = len(key)

    # Pad plaintext if necessary
    if len(plaintext) % n != 0:
        plaintext += 'X' * (n - len(plaintext) % n)

    ciphertext = ""
    for i in range(0, len(plaintext), n):
        plaintext_block = plaintext[i:i+n]
        plaintext_numbers = matrix_to_numbers([plaintext_block])
        ciphertext_numbers = (np.dot(key_matrix, plaintext_numbers) % 26).tolist()
        ciphertext += numbers_to_matrix(ciphertext_numbers)

    return ciphertext

def hill_decrypt(ciphertext, key):
    key_matrix = np.array(key)
    key_inverse = matrix_mod_inv(key_matrix, 26)
    ciphertext = ciphertext.upper().replace(" ", "")
    n = len(key)

    plaintext = ""
    for i in range(0, len(ciphertext), n):
        ciphertext_block = ciphertext[i:i+n]
        ciphertext_numbers = matrix_to_numbers([ciphertext_block])
        plaintext_numbers = (np.dot(key_inverse, ciphertext_numbers) % 26).tolist()
        plaintext += numbers_to_matrix(plaintext_numbers)

    return plaintext

# Example usage:
plaintext = "HELLO"
key = [[3, 2], [2, 5]]  # Example key matrix
encrypted_text = hill_encrypt(plaintext, key)
print("Encrypted:", encrypted_text)
decrypted_text = hill_decrypt(encrypted_text, key)
print("Decrypted:", decrypted_text)

6.Implement Diffie Hellman algorithm. (Encryption and decryption)..........

from random import randint

def mod_exp(base, exponent, modulus):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent = exponent // 2
    return result

def generate_keys(prime, generator):
    private_key = randint(2, prime - 2)
    public_key = mod_exp(generator, private_key, prime)
    return private_key, public_key

def generate_shared_secret(private_key, other_public_key, prime):
    return mod_exp(other_public_key, private_key, prime)

# Example usage:
prime = 23  # Example prime number
generator = 5  # Example generator

# Alice's side
alice_private_key, alice_public_key = generate_keys(prime, generator)
print("Alice's private key:", alice_private_key)
print("Alice's public key:", alice_public_key)

# Bob's side
bob_private_key, bob_public_key = generate_keys(prime, generator)
print("Bob's private key:", bob_private_key)
print("Bob's public key:", bob_public_key)

# Shared secret computation
shared_secret_alice = generate_shared_secret(alice_private_key, bob_public_key, prime)
shared_secret_bob = generate_shared_secret(bob_private_key, alice_public_key, prime)

print("Shared secret computed by Alice:", shared_secret_alice)
print("Shared secret computed by Bob:", shared_secret_bob)



