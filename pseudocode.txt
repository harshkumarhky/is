1.Implement Caesar Cipher algorithm. (Encryption and decryption).........


function caesar_encrypt(text, shift):
    encrypted_text = ""
    for each character char in text:
        if char is alphabetic:
            shifted = ASCII(char) + shift
            if char is lowercase:
                if shifted > ASCII('z'):
                    shifted = shifted - 26
                else if shifted < ASCII('a'):
                    shifted = shifted + 26
            else if char is uppercase:
                if shifted > ASCII('Z'):
                    shifted = shifted - 26
                else if shifted < ASCII('A'):
                    shifted = shifted + 26
            encrypted_text = encrypted_text + ASCII_to_char(shifted)
        else:
            encrypted_text = encrypted_text + char
    return encrypted_text

function caesar_decrypt(text, shift):
    return caesar_encrypt(text, -shift)

plaintext = "Hello, World!"
shift = 3
encrypted_text = caesar_encrypt(plaintext, shift)
print("Encrypted:", encrypted_text)
decrypted_text = caesar_decrypt(encrypted_text, shift)
print("Decrypted:", decrypted_text)


2.Implement Rail Fence algorithm. (Encryption and decryption)......

function rail_fence_encrypt(text, rails):
    // Initialize an empty fence
    fence = create a list of rails empty lists

    // Set initial position and direction
    rail = 0
    direction = 1

    // Traverse the plaintext characters and fill the fence
    for each character char in text:
        // Append the character to the corresponding rail
        fence[rail].append(char)
        
        // Move to the next rail based on the direction
        rail = rail + direction
        
        // Change direction if reaching the top or bottom rail
        if rail equals to rails - 1 or rail equals to 0:
            direction = -direction

    // Concatenate characters from each rail to form the encrypted text
    encrypted_text = join all characters in all rows of the fence into a single string
    return encrypted_text

function rail_fence_decrypt(text, rails):
    // Initialize an empty fence with '*' placeholders
    fence = create a list of rails lists, each initialized with '' characters
    rail = 0
    direction = 1

    // Fill in the '*' placeholders with ciphertext characters
    for i in range(length of text):
        fence[rail][i] = '*'
        rail = rail + direction
        if rail equals to rails - 1 or rail equals to 0:
            direction = -direction

    // Replace '*' placeholders with characters from the ciphertext
    index = 0
    for i in range(rails):
        for j in range(length of text):
            if fence[i][j] equals to '*' and index less than length of text:
                fence[i][j] = text[index]
                index = index + 1

    // Reconstruct the plaintext from the filled fence
    rail = 0
    direction = 1
    decrypted_text = ''
    for each character in the text:
        // Append the character from the current rail to the decrypted text
        decrypted_text = decrypted_text + fence[rail][0]
        // Remove the character from the current rail
        delete the first character from the current rail
        // Move to the next rail based on the direction
        rail = rail + direction
        // Change direction if reaching the top or bottom rail
        if rail equals to rails - 1 or rail equals to 0:
            direction = -direction

    return decrypted_text

// Example usage:
plaintext = "Hello, World!"
rails = 3
encrypted_text = rail_fence_encrypt(plaintext, rails)
print("Encrypted:", encrypted_text)
decrypted_text = rail_fence_decrypt(encrypted_text, rails)
print("Decrypted:", decrypted_text)


3.Implement Play fair algorithm. (Encryption and decryption)..........

function prepare_text(text):
    // Convert text to uppercase and remove spaces
    text = convert text to uppercase and remove spaces
    // Replace 'J' with 'I'
    text = replace 'J' with 'I' in text
    // Split text into digraphs
    digraphs = []
    i = 0
    while i < length of text:
        if i + 1 < length of text and text[i] equals to text[i + 1]:
            // Append digraph with 'X' if two consecutive letters are the same
            digraphs.append(text[i] + "X")
            i = i + 1
        else:
            // Append digraph of two consecutive letters
            digraphs.append(text[i:i + 2])
            i = i + 2
    return digraphs

function build_playfair_matrix(key):
    // Initialize Playfair matrix with the key
    matrix = []
    for each character char in uppercase of key:
        if char not in matrix and char is not 'J':
            // Add character to matrix if not already present and not 'J'
            matrix.append(char)
    // Fill in the rest of the matrix with remaining letters
    for each character char in uppercase of "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in matrix:
            matrix.append(char)
    // Reshape matrix into a 5x5 grid
    matrix = reshape matrix into a 5x5 grid
    return matrix

function find_letter_positions(matrix, letter):
    for i in range(5):
        for j in range(5):
            if matrix[i][j] equals to letter:
                return i, j

function playfair_encrypt(plaintext, key):
    plaintext = prepare_text(plaintext)
    matrix = build_playfair_matrix(key)
    ciphertext = ""
    for each digraph in plaintext:
        row1, col1 = find_letter_positions(matrix, first character of digraph)
        row2, col2 = find_letter_positions(matrix, second character of digraph)
        if row1 equals to row2:
            // If both letters are in the same row, shift each letter to the right
            ciphertext = ciphertext + matrix[row1][(col1 + 1) modulo 5] + matrix[row2][(col2 + 1) modulo 5]
        else if col1 equals to col2:
            // If both letters are in the same column, shift each letter downwards
            ciphertext = ciphertext + matrix[(row1 + 1) modulo 5][col1] + matrix[(row2 + 1) modulo 5][col2]
        else:
            // If letters are not in the same row or column, form rectangle and swap letters
            ciphertext = ciphertext + matrix[row1][col2] + matrix[row2][col1]
    return ciphertext

function playfair_decrypt(ciphertext, key):
    ciphertext = prepare_text(ciphertext)
    matrix = build_playfair_matrix(key)
    plaintext = ""
    for each digraph in ciphertext:
        row1, col1 = find_letter_positions(matrix, first character of digraph)
        row2, col2 = find_letter_positions(matrix, second character of digraph)
        if row1 equals to row2:
            // If both letters are in the same row, shift each letter to the left
            plaintext = plaintext + matrix[row1][(col1 - 1) modulo 5] + matrix[row2][(col2 - 1) modulo 5]
        else if col1 equals to col2:
            // If both letters are in the same column, shift each letter upwards
            plaintext = plaintext + matrix[(row1 - 1) modulo 5][col1] + matrix[(row2 - 1) modulo 5][col2]
        else:
            // If letters are not in the same row or column, form rectangle and swap letters
            plaintext = plaintext + matrix[row1][col2] + matrix[row2][col1]
    return plaintext

// Example usage:
plaintext = "HELLO"
key = "PLAYFAIR EXAMPLE"
encrypted_text = playfair_encrypt(plaintext, key)
print("Encrypted:", encrypted_text)
decrypted_text = playfair_decrypt(encrypted_text, key)
print("Decrypted:", decrypted_text)


4.Implement Vigenere Cipher algorithm. (Encryption and decryption).........


function extend_keyword(keyword, length):
    extended_keyword = keyword
    while length of extended_keyword < length:
        extended_keyword = extended_keyword + keyword
    return first length characters of extended_keyword

function vigenere_encrypt(plaintext, keyword):
    keyword = extend_keyword(keyword, length of plaintext)
    encrypted_text = ""
    for i from 0 to length of plaintext - 1:
        if ith character of plaintext is alphabetic:
            shift = ASCII value of ith character of keyword (uppercase) - ASCII value of 'A'
            if ith character of plaintext is lowercase:
                encrypted_text = encrypted_text + ith character of plaintext shifted by (shift modulo 26) (keeping it within lowercase range)
            else:
                encrypted_text = encrypted_text + ith character of plaintext shifted by (shift modulo 26) (keeping it within uppercase range)
        else:
            encrypted_text = encrypted_text + ith character of plaintext
    return encrypted_text

function vigenere_decrypt(ciphertext, keyword):
    keyword = extend_keyword(keyword, length of ciphertext)
    decrypted_text = ""
    for i from 0 to length of ciphertext - 1:
        if ith character of ciphertext is alphabetic:
            shift = ASCII value of ith character of keyword (uppercase) - ASCII value of 'A'
            if ith character of ciphertext is lowercase:
                decrypted_text = decrypted_text + ith character of ciphertext shifted by ((26 - shift) modulo 26) (keeping it within lowercase range)
            else:
                decrypted_text = decrypted_text + ith character of ciphertext shifted by ((26 - shift) modulo 26) (keeping it within uppercase range)
        else:
            decrypted_text = decrypted_text + ith character of ciphertext
    return decrypted_text

// Example usage:
plaintext = "HELLO"
keyword = "KEY"
encrypted_text = vigenere_encrypt(plaintext, keyword)
print("Encrypted:", encrypted_text)
decrypted_text = vigenere_decrypt(encrypted_text, keyword)
print("Decrypted:", decrypted_text)


5.Implement Hill Cipher algorithm. (Encryption and decryption) (Omitted from practical exam.).......

function matrix_mod_inv(matrix, modulus):
    det = round(det(matrix)) modulo modulus
    det_inv = modular_inverse(det, modulus)  // Calculate modular inverse of determinant

    // Calculate adjugate matrix
    adjugate = round(det * inverse(matrix)) modulo modulus

    // Calculate inverse matrix
    inverse = (det_inv * adjugate) modulo modulus

    return inverse

function matrix_to_numbers(matrix):
    numbers = []
    for each character char in concatenate characters of matrix:
        number = ASCII value of char - ASCII value of 'A'
        add number to numbers
    return numbers

function numbers_to_matrix(numbers):
    matrix = ""
    for each number in numbers:
        char = (number modulo 26) + ASCII value of 'A'
        append character char to matrix
    return matrix

function hill_encrypt(plaintext, key):
    key_matrix = create a matrix from key
    plaintext = remove spaces from plaintext and convert to uppercase
    n = number of rows in key_matrix

    // Pad plaintext if necessary
    if length of plaintext modulo n is not 0:
        plaintext = plaintext + 'X' repeated (n - (length of plaintext modulo n)) times

    ciphertext = ""
    for i from 0 to length of plaintext - 1 in steps of n:
        plaintext_block = substring of plaintext from index i to (i + n - 1)
        plaintext_numbers = matrix_to_numbers(plaintext_block)
        ciphertext_numbers = (key_matrix * plaintext_numbers) modulo 26
        ciphertext = ciphertext + numbers_to_matrix(ciphertext_numbers)

    return ciphertext

function hill_decrypt(ciphertext, key):
    key_matrix = create a matrix from key
    key_inverse = matrix_mod_inv(key_matrix, 26)
    ciphertext = remove spaces from ciphertext and convert to uppercase
    n = number of rows in key_matrix

    plaintext = ""
    for i from 0 to length of ciphertext - 1 in steps of n:
        ciphertext_block = substring of ciphertext from index i to (i + n - 1)
        ciphertext_numbers = matrix_to_numbers(ciphertext_block)
        plaintext_numbers = (key_inverse * ciphertext_numbers) modulo 26
        plaintext = plaintext + numbers_to_matrix(plaintext_numbers)

    return plaintext

// Example usage:
plaintext = "HELLO"
key = [[3, 2], [2, 5]]  // Example key matrix
encrypted_text = hill_encrypt(plaintext, key)
print("Encrypted:", encrypted_text)
decrypted_text = hill_decrypt(encrypted_text, key)
print("Decrypted:", decrypted_text)


6.Implement Diffie Hellman algorithm. (Encryption and decryption)..........

function mod_exp(base, exponent, modulus):
    result = 1
    while exponent > 0:
        if exponent is odd:
            result = (result * base) modulo modulus
        base = (base * base) modulo modulus
        exponent = exponent / 2
    return result

function generate_keys(prime, generator):
    private_key = random integer between 2 and (prime - 2)
    public_key = mod_exp(generator, private_key, prime)
    return private_key, public_key

function generate_shared_secret(private_key, other_public_key, prime):
    return mod_exp(other_public_key, private_key, prime)

// Example usage:
prime = 23  // Example prime number
generator = 5  // Example generator

// Alice's side
alice_private_key, alice_public_key = generate_keys(prime, generator)
print("Alice's private key:", alice_private_key)
print("Alice's public key:", alice_public_key)

// Bob's side
bob_private_key, bob_public_key = generate_keys(prime, generator)
print("Bob's private key:", bob_private_key)
print("Bob's public key:", bob_public_key)

// Shared secret computation
shared_secret_alice = generate_shared_secret(alice_private_key, bob_public_key, prime)
shared_secret_bob = generate_shared_secret(bob_private_key, alice_public_key, prime)

print("Shared secret computed by Alice:", shared_secret_alice)
print("Shared secret computed by Bob:", shared_secret_bob)



